/* ~.~ *-c-*
 *
 * Copyright (c) 2013, John Lee <furious_tauren@163.com>
 * Wed Jun 11 17:58:47 CST 2014
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
 * MA 02111-1307 USA
 */
#include <asm/arch/cpu.h>
#include <asm/arch/clock.h>
#include <asm/arch/hardware.h>
#include <asm/io.h>

/* ------------------------------------------------------------------------------
 * timer
 * ------------------------------------------------------------------------------
 */
#define TMR_BASE		DM_TIMER2_BASE

#define TIMER_CLOCK		(V_OSCK / (2 << 2))
int timer_init(void)
{
	void *base = (void *)TMREG_BASE;

	/* start the counter ticking up, reload value on overflow */
	writel(0, base + TMREG_TLDR);

	/* enable timer */
	writel(2 << 2 | 1 << 5 | 1 << 1 | 1, base + TMREG_TCLR);

	return 0;
}


/* delay x useconds */
void udelay(unsigned long usec)
{
	long tmo;
	void *base;
	unsigned long now, last;

	tmo = usec * (TIMER_CLOCK / 1000) / 1000;
	base = (void *)TMR_BASE;
	last = readl(base + TMREG_TCRR);

	while (tmo > 0) {
		now = readl(base + TMREG_TCRR);
		if (last > now)	/* count up timer overflow */
			tmo -= TIMER_OVERFLOW_VAL - last + now + 1;
		else
			tmo -= now - last;
		last = now;
	}
}

/* ------------------------------------------------------------------------------
 * wdt
 * ------------------------------------------------------------------------------
 */

static void watchdog_disable(void)
{
	void *wdt_base = (void *)WDT_BASE;

	writel(0xaaaa, wdt_base + WDTREG_WSPR);
	while (readl(wdt_base + WDTREG_WWPS) != 0x0)
		;

	writel(0x5555, wdt_base + WDTREG_WSPR);
	while (readl(wdt_base + WDTREG_WWPS) != 0x0)
		;
}


/* ------------------------------------------------------------------------------
 * on-board rtc
 * ------------------------------------------------------------------------------
 */
#define RTC_KICK0R_WE		0x83e70b13
#define RTC_KICK1R_WE		0x95a4f1e0

static void rtc32k_enable(void)
{
	void *rtc_base = (void *)RTC_BASE;

	/*
	 * Unlock the RTC's registers.  For more details please see the
	 * RTC_SS section of the TRM.  In order to unlock we need to
	 * write these specific values (keys) in this order.
	 */
	writel(RTC_KICK0R_WE, rtc_base + RTCREG_KICK0R);
	writel(RTC_KICK1R_WE, rtc_base + RTCREG_KICK0R);

	/* Enable the RTC 32K OSC by setting bits 3 and 6. */
	writel((1 << 3) | (1 << 6), rtc_base + RTCREG_OSC);
}

/* ------------------------------------------------------------------------------
 * pin mux
 * ------------------------------------------------------------------------------
 */
#define PAD_CTRL_BASE	0x800

#define MUX_UART_RXD(x)	(0x5c * 0x4 + 0xc * (x))
#define MUX_UART_TXD(x)	(0x5e * 0x4 + 0xc * (x))

#define MUX_GPMC_AD(x)		((x) * 0x4)
#define MUX_GPMC_A(x)		(MUX_GPMC_AD(0xf) + (x) * 0x4)
#define MUX_GPMC_WAIT0		(MUX_GPMC_A(0xb) + 0x4)
#define MUX_GPMC_WPN		(MUX_GPMC_WAIT0 + 0x4)
#define MUX_GPMC_CSN(x)		(MUX_GPMC_WPN + 0x8 + 0x4 * (x))
#define MUX_GPMC_ADVN_ALE	(MUX_GPMC_CSN(0x3) + 0x8)
#define MUX_GPMC_OEN_REN	(MUX_GPMC_ADVN_ALE + 0x4)
#define MUX_GPMC_WEN		(MUX_GPMC_OEN_REN + 0x4)
#define MUX_GPMC_BE0N_CLE	(MUX_GPMC_WEN + 0x4)


/* PAD Control Fields */
#define SLEWCTRL	(0x1 << 6)
#define RXACTIVE	(0x1 << 5)
#define PULLDOWN_EN	(0x0 << 4)	/* Pull Down Selection */
#define PULLUP_EN	(0x1 << 4)	/* Pull Up Selection */
#define PULLUDEN	(0x0 << 3)	/* Pull up enabled */
#define PULLUDDIS	(0x1 << 3)	/* Pull up disabled */
#define MODE(val)	val		/* used for Readability */

struct module_pin_mux {
	short		reg_offs;
	unsigned int	val;
};

static struct module_pin_mux uart0_pin_mux[] = {
	{ MUX_UART_RXD(0),	PULLUP_EN | RXACTIVE },	/* UART0_RXD */
	{ MUX_UART_TXD(0),	PULLUDEN },		/* UART0_TXD */
	{ -1 },
};

static struct module_pin_mux nand_pin_mux[] = {
	{ MUX_GPMC_AD(0),	PULLUP_EN | RXACTIVE },	/* NAND AD0 */
	{ MUX_GPMC_AD(1),	PULLUP_EN | RXACTIVE },	/* NAND AD1 */
	{ MUX_GPMC_AD(2),	PULLUP_EN | RXACTIVE },	/* NAND AD2 */
	{ MUX_GPMC_AD(3),	PULLUP_EN | RXACTIVE },	/* NAND AD3 */
	{ MUX_GPMC_AD(4),	PULLUP_EN | RXACTIVE },	/* NAND AD4 */
	{ MUX_GPMC_AD(5),	PULLUP_EN | RXACTIVE },	/* NAND AD5 */
	{ MUX_GPMC_AD(6),	PULLUP_EN | RXACTIVE },	/* NAND AD6 */
	{ MUX_GPMC_AD(7),	PULLUP_EN | RXACTIVE },	/* NAND AD7 */
	{ MUX_GPMC_WAIT0,	PULLUP_EN | RXACTIVE },	/* NAND WAIT */
	{ MUX_GPMC_WPN,		PULLUP_EN | RXACTIVE },	/* NAND_WPN */
	{ MUX_GPMC_CSN(0),	PULLUDEN },		/* NAND_CS0 */
	{ MUX_GPMC_ADVN_ALE,	PULLUDEN },		/* NAND_ADV_ALE */
	{ MUX_GPMC_OEN_REN,	PULLUDEN },		/* NAND_OE */
	{ MUX_GPMC_WEN,		PULLUDEN },		/* NAND_WEN */
	{ MUX_GPMC_BE0N_CLE,	PULLUDEN },		/* NAND_BE_CLE */
	{ -1 },
};

/* Configure the pin mux for the module */
void configure_module_pin_mux(struct module_pin_mux *mux)
{
	void *ctrl_base = (void *)(PRCM_BASE + PAD_CTRL_BASE);
	int i;

	for (i = 0; mux[i].reg_offs != -1; i++)
		__raw_writel(mux[i].val, (ctrl_base + mux[i].reg_offs));
}

/* ------------------------------------------------------------------------------
 * gpmc
 * ------------------------------------------------------------------------------
 */
void sdelay(unsigned long loops)
{
	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
			  "bne 1b":"=r" (loops):"0"(loops));
}

void enable_gpmc_cs_config(const u32 *cfg, void *cs, u32 base, u32 size)
{
	int i;

	writel(0, cs + 0x4 * 6);
	sdelay(1000);

	/* Delay for settling */
	for (i = 0; cfg[i] != 0; i++)
		writel(cfg[i], cs + 0x4 * i);

	/* Enable the config */
	writel((((size & 0xF) << 8) | ((base >> 24) & 0x3F)
				| (1 << 6)), cs + 0x4 * 6);
	sdelay(2000);
}

void gpmc_init(void)
{
	/* putting a blanket check on GPMC based on ZeBu for now */
	void *gpmc_base = (void *)GPMC_BASE;
	void *cs_base = gpmc_base + GPMCREG_CS0_CONFIG1;

	/* configure GPMC for NAND */
	const u32 gpmc_regs[7] = {
		M_NAND_GPMC_CONFIG1,
		M_NAND_GPMC_CONFIG2,
		M_NAND_GPMC_CONFIG3,
		M_NAND_GPMC_CONFIG4,
		M_NAND_GPMC_CONFIG5,
		M_NAND_GPMC_CONFIG6,
		0
	};

	u32 size = GPMC_SIZE_256M;
	u32 base = CONFIG_SYS_NAND_BASE;

	/* global settings */
	writel(0x00000008, gpmc_base + GPMCREG_SYSCONFIG);
	writel(0x00000000, gpmc_base + GPMCREG_IRQSTATUS);
	writel(0x00000000, gpmc_base + GPMCREG_IRQENABLE);

	writel(0x00000012, gpmc_base + GPMCREG_CONFIG);

	/* enable chip-select specific configurations */
	enable_gpmc_cs_config(gpmc_regs, cs_base, base, size);
}


struct ctrl_dev {
	unsigned int deviceid;		/* offset 0x00 */
	unsigned int resv1[7];
	unsigned int usb_ctrl0;		/* offset 0x20 */
	unsigned int resv2;
	unsigned int usb_ctrl1;		/* offset 0x28 */
	unsigned int resv3;
	unsigned int macid0l;		/* offset 0x30 */
	unsigned int macid0h;		/* offset 0x34 */
	unsigned int macid1l;		/* offset 0x38 */
	unsigned int macid1h;		/* offset 0x3c */
	unsigned int resv4[4];
	unsigned int miisel;		/* offset 0x50 */
	unsigned int resv5[106];
	unsigned int efuse_sma;		/* offset 0x1FC */
};


int am335x_get_tps65910_mpu_vdd(int sil_rev, int frequency)
{
	/* For PG2.1 and later, we have one set of values. */
	if (sil_rev >= 2) {
		switch (frequency) {
		case MPUPLL_M_1000:
			return TPS65910_OP_REG_SEL_1_3_2_5;
		case MPUPLL_M_800:
			return TPS65910_OP_REG_SEL_1_2_6;
		case MPUPLL_M_720:
			return TPS65910_OP_REG_SEL_1_2_0;
		case MPUPLL_M_600:
		case MPUPLL_M_300:
			return TPS65910_OP_REG_SEL_1_1_3;
		}
	}

	/* Default to PG1.0/PG2.0 values. */
	return TPS65910_OP_REG_SEL_1_1_3;
}
void lowlevel_init(void)
{
	watchdog_disable();

	configure_module_pin_mux(uart0_pin_mux);
	prcm_init();

	configure_module_pin_mux(nand_pin_mux);

	config_ddr(303, MT41J512M8RH125_IOCTRL_VALUE, &ddr3_evm_data,
			   &ddr3_evm_cmd_ctrl_data, &ddr3_evm_emif_reg_data, 0);
}


