#include "os_includes.h"
#include "Flash.h"
#include "consol.h"
#include "HugeBuf.h"
#include "status.h"
#include "keylcd.h"

#if (INCLUDE_CONSOL == 1)
#include <stdio.h>
#endif

#include <board_memories.h>
#include <pio/pio.h>
#include <utility/trace.h>
#include <utility/math.h>
#include <memories/nandflash/SkipBlockNandFlash.h>

#include <string.h>

#include "FileLUT.h"
#include "LED.h"

// Nandflash bus width
#ifdef ek_board_sim
static unsigned char nfBusWidth = 16;
#else
#ifdef NF_CHIP_K9F5608U0D
//we select K9F5608U0D as Nand flash chip. 
//K9F5608U0D's bus width is 8.
static unsigned char nfBusWidth = 8;
#endif
#endif
unsigned char bInitNandFlash = False;

/// Pins used to access to nandflash.
static const Pin pPinsNf[] = {PINS_NANDFLASH};
/// Nandflash device structure.
static struct SkipBlockNandFlash skipBlockNf;
/// Address for transferring command bytes to the nandflash.
static unsigned int cmdBytesAddr = BOARD_NF_COMMAND_ADDR;
/// Address for transferring address bytes to the nandflash.
static unsigned int addrBytesAddr = BOARD_NF_ADDRESS_ADDR;
/// Address for transferring data bytes to the nandflash.
static unsigned int dataBytesAddr = BOARD_NF_DATA_ADDR;
/// Nandflash chip enable pin.
static const Pin nfCePin = BOARD_NF_CE_PIN;
/// Nandflash ready/busy pin.
static const Pin nfRbPin = BOARD_NF_RB_PIN;
/// Nandflash write protect pin.
static const Pin nfWpPin = BOARD_NF_WP_PIN;

static struct FLUT_RequireItem BinItem;

#define MAX_CODE_SIZE 0x100000 //when sim case, code will be placed at DDR2

static void PrepareCoreBinItem(struct FLUT_RequireItem * pCoreBinItem, void * pCodeS, INT32U len)
{
	memset(pCoreBinItem, 0xFF, sizeof(struct FLUT_RequireItem));
	
	pCoreBinItem->fileID = FLUT_ITEM_ID_ASYSTEM_CORE;
	pCoreBinItem->bufferSize = NandCommon_MAXPAGEDATASIZE * NandCommon_MAXNUMPAGESPERBLOCK;
	pCoreBinItem->readWrittenSize = 0;
	pCoreBinItem->copyBuffer = (unsigned char *)AT91C_DDR2+MAX_CODE_SIZE;
	pCoreBinItem->writeFileOrCacheFile.ID = FLUT_ITEM_ID_ASYSTEM_CORE;
	pCoreBinItem->writeFileOrCacheFile.Size = len;
	strcpy(pCoreBinItem->writeFileOrCacheFile.FileDescription, "BYHX ASys Core");
	pCoreBinItem->writeFileOrCacheFile.Checksum = CalcChksum(pCodeS, len);
}

static void PrepareFPGABinItem(struct FLUT_RequireItem * pFPGABinItem, void * pCodeS, INT32U len)
{
	memset(pFPGABinItem, 0xFF, sizeof(struct FLUT_RequireItem));
	
	pFPGABinItem->fileID = FLUT_ITEM_ID_ASYSTEM_FPGA;
	pFPGABinItem->bufferSize = NandCommon_MAXPAGEDATASIZE * NandCommon_MAXNUMPAGESPERBLOCK;
	pFPGABinItem->readWrittenSize = 0;
	pFPGABinItem->copyBuffer = (unsigned char *)AT91C_DDR2+MAX_CODE_SIZE;
	pFPGABinItem->writeFileOrCacheFile.ID = FLUT_ITEM_ID_ASYSTEM_FPGA;
	pFPGABinItem->writeFileOrCacheFile.Size = len;
	strcpy(pFPGABinItem->writeFileOrCacheFile.FileDescription, "BYHX ASys FPGA");
	pFPGABinItem->writeFileOrCacheFile.Checksum = CalcChksum(pCodeS, len);
}

static unsigned char WriteBinItem(struct FLUT_RequireItem * pBinItem, void * pSrc)
{
	int writecount = 0;
	
	unsigned char error = FLUT_StartWriteFile(pBinItem);
	if(error != EC_FLUT_NO_ERROR)
		return error;
	
	while(writecount<pBinItem->writeFileOrCacheFile.Size)
	{
		int currentlen = pBinItem->writeFileOrCacheFile.Size - writecount;
		if(currentlen > pBinItem->bufferSize)
			currentlen = pBinItem->bufferSize;
		memcpy(pBinItem->copyBuffer, (unsigned char*)pSrc+writecount, currentlen);
		pBinItem->readWrittenSize = currentlen;
		error = FLUT_WriteNextBuffer(pBinItem);
		if(error != EC_FLUT_NO_ERROR)
			return error;
		writecount+= currentlen;
	}
	return EC_FLUT_NO_ERROR;
}

static INT8U InitNandFlash()
{
	if(!bInitNandFlash)
	{
		BOARD_ConfigureNandFlash(nfBusWidth);
		PIO_Configure(pPinsNf, PIO_LISTSIZE(pPinsNf));
		
		memset(&skipBlockNf, 0, sizeof(skipBlockNf));
		
		//for ek board sim, when initial, nfBusWidth must be 16bits.
		if (SkipBlockNandFlash_Initialize(&skipBlockNf,
										  0,
										  cmdBytesAddr,
										  addrBytesAddr,
										  dataBytesAddr,
										  nfCePin,
										  nfRbPin,
										  nfWpPin)) {
											  
											  TRACE_ERROR("\tDevice Unknown\n\r");
											  return False;
										  }
		else
		{
			// Check the data bus width of the NandFlash
			nfBusWidth = NandFlashModel_GetDataBusWidth((struct NandFlashModel *)&skipBlockNf);
			// Reconfigure bus width
			BOARD_ConfigureNandFlash(nfBusWidth);
			bInitNandFlash = True;
		}
	}
	return True;
}

#define VERSION_TAG_OFFSET (0x200+0x30)
#define CUR_CODE_VERSION 0x10001
#define GZ_KEY_TAG_OFFSET (0x200+0x3C)
#define INK_PWD_TAG_OFFSET (0x200+0x40)
#define HW_CFG_TAG_OFFSET (0x200+0x44)
INT8S Flash_UpdateCode(struct Struct_Updater *codeInfo, UBYTE index)
{
	INT16U *pCodeS;
	INT8U ret;
	unsigned char error = 0;
	INT32U addr;
	
	OS_CPU_SR  cpu_sr;	
	
	pCodeS = (INT16U *)((INT32U)HugeBuf_GetCodeAddr(codeInfo->data_bytescnt) + codeInfo->SubAddressTable[index]);
	
	if(codeInfo->FileVersion == 2 && codeInfo->SubSizeTable[index] != 0 )
	{
		addr = ((INT32U)HugeBuf_GetCodeAddr(codeInfo->data_bytescnt) + 
				codeInfo->SubAddressTable[index]);
		DeSecurity((INT8U *)addr, (INT8U *)addr, 0x400);
	}
	if ((*(INT32U *)((INT32U)pCodeS+VERSION_TAG_OFFSET) != 0x334E5342) || 
		(*(INT32U *)((INT32U)pCodeS+VERSION_TAG_OFFSET + sizeof(INT32U)) != 0x49313235) ||
			(*(INT32U *)((INT32U)pCodeS+VERSION_TAG_OFFSET + 2*sizeof(INT32U)) != 0x10001)  )
	{	
		CONSOL_Printf("Unsupported files!\r\n");
		CONSOL_Printf("data adress: 0x%x", pCodeS);
		CONSOL_Printf("data 0x28:%x\r\n", *(INT32U *)(pCodeS+0x28));
		status_ReportStatus(STATUS_UPDATEERR_ILIGALFILE,STATUS_SET);
		return False;
	}
	
#ifdef GZ_KEY_USED	
	if ((*(INT32U *)((INT32U)pCodeS + GZ_KEY_TAG_OFFSET) != 0x554B4559))
	{	
		status_ReportStatus(STATUS_UPDATEERR_GZ_ILIGALFILE,STATUS_SET);
		return False;
	}
#endif	
	
#ifdef INK_PASSWORD	
	if ((*(INT32U *)((INT32U)pCodeS+INK_PWD_TAG_OFFSET) != 0x504B4E49))
	{	
		status_ReportStatus(STATUS_UPDATEERR_INKP_ILIGALFILE,STATUS_SET);
		return False;
	}
#endif	
	
#ifdef HARDWARE_CONFIGURE
	CONSOL_Printf("HD Check: %x, %x, %x, %x ", *(__packed INT32U *)((INT32U)pCodeS+HW_CFG_TAG_OFFSET),
				  (*(__packed INT32U *)((INT32U)pCodeS+HW_CFG_TAG_OFFSET + sizeof(INT32U)),
				   (*(__packed INT32U *)((INT32U)pCodeS+HW_CFG_TAG_OFFSET + 2*sizeof(INT32U)) & HW_CNF_BIT_SDRAM_SIZE)),
				  SDRAM_SIZE);
	if ((*(__packed INT32U *)((INT32U)pCodeS+HW_CFG_TAG_OFFSET) == HW_CNF_TAG))
	{	
		if ((*(__packed INT32U *)((INT32U)pCodeS+HW_CFG_TAG_OFFSET + sizeof(INT32U)) >= 0x10001))
		{
		}
	}
#endif
	
	ret = False;
	
#ifdef IIC_Key_Board_LCD	
	LCD_Text(0,0, "Updating Main FW...     ");
#endif	
	LED_Display(LED_BOOT_RUN, LED_LIGHT);
	
	if(codeInfo->FileVersion != 2 && codeInfo->SubSizeTable[index] != 0 )
	{
		addr = ((INT32U)HugeBuf_GetCodeAddr(codeInfo->data_bytescnt) + 
				codeInfo->SubAddressTable[index]);
		EnSecurity((INT8U *)addr, (INT8U *)addr, codeInfo->SubSizeTable[index]);
	}
	else
	{
		addr = ((INT32U)HugeBuf_GetCodeAddr(codeInfo->data_bytescnt) + 
				codeInfo->SubAddressTable[index]);
		EnSecurity((INT8U *)addr, (INT8U *)addr, 0x400);
	}
	
	if(InitNandFlash())
	{
		FLUT_Configure(&skipBlockNf);
		
		PrepareCoreBinItem(&BinItem, pCodeS, codeInfo->SubSizeTable[index]);
		
		OS_ENTER_CRITICAL();			
		error = WriteBinItem(&BinItem, pCodeS);
		OS_EXIT_CRITICAL();
		if(error != EC_FLUT_NO_ERROR)
		{
			TRACE_ERROR("Write CoreBin failure: 0x%x \n\r", error);
			TRACE_ERROR("currentFilePosition : 0x%x \n\r",BinItem.currentFilePosition);
			TRACE_ERROR("currentOffset : 0x%x \n\r",BinItem.currentOffset);
		}
		ret = True;
	}
	
	LED_Display(LED_BOOT_RUN, LED_DARK);
	
	if (ret)
	{
#ifdef IIC_Key_Board_LCD	
		LCD_Text(0,0, "Update Main FW Success! ");
#endif		
	}
	else
	{
		status_ReportStatus(STATUS_UPDATEERR_FLASHOP, STATUS_SET);	
#ifdef IIC_Key_Board_LCD		
		LCD_Text(0,0, "Update Main FW Failed!  ");		
#endif		
	}
	OSTimeDly(1000);
	//status_ReportStatus(0, STATUS_SET);	
	return ret;
}

INT8S Flash_UpdateFPGA(struct Struct_Updater *codeInfo, UBYTE index)
{
	INT16U *pCodeS;
	INT8U ret;
	unsigned char error = 0;
	
	OS_CPU_SR  cpu_sr;	
	
	pCodeS = (INT16U *)((INT32U)HugeBuf_GetCodeAddr(codeInfo->data_bytescnt) + codeInfo->SubAddressTable[index]);
	
	ret = False;
	
#ifdef IIC_Key_Board_LCD	
	LCD_Text(0,0, "Updating FPGA...");
#endif	
	
	//LED_Configure(FALSE);
	LED_Display(LED_BOOT_RUN, LED_LIGHT);
	
	if(InitNandFlash())
	{
		FLUT_Configure(&skipBlockNf);
		
		PrepareFPGABinItem(&BinItem, pCodeS, codeInfo->SubSizeTable[index]);
		
		OS_ENTER_CRITICAL();
		error = WriteBinItem(&BinItem, pCodeS);
		OS_EXIT_CRITICAL();
		if(error != EC_FLUT_NO_ERROR)
		{
			TRACE_ERROR("Write CoreBin failure: 0x%x \n\r", error);
			TRACE_ERROR("currentFilePosition : 0x%x \n\r",BinItem.currentFilePosition);
			TRACE_ERROR("currentOffset : 0x%x \n\r",BinItem.currentOffset);
		}
		ret = True;
	}
	
	LED_Display(LED_BOOT_RUN, LED_DARK);
	
	if (ret)
	{
#ifdef IIC_Key_Board_LCD	
		LCD_Text(0,0, "Update FPGA Success! ");
#endif		
	}
	else
	{
		status_ReportStatus(STATUS_UPDATEERR_FLASHOP, STATUS_SET);	
#ifdef IIC_Key_Board_LCD		
		LCD_Text(0,0, "Update FPGA Failed!  ");		
#endif		
	}
	//	OSTimeDly(1000);
	//status_ReportStatus(0, STATUS_SET);	
	return ret;
}

unsigned char ReadFPGA(INT32U * pFileLen, INT8U ** FPGA_File_Location)
{
	unsigned char error = 0;
	int copycount = 0;
	unsigned int checksum = 0;
	
	OS_CPU_SR  cpu_sr;	
	
	*FPGA_File_Location = (INT8U *)(AT91C_DDR2 + MAX_CODE_SIZE + NandCommon_MAXPAGEDATASIZE * NandCommon_MAXNUMPAGESPERBLOCK);
	*pFileLen = 0;
	
	//LED_Configure(FALSE);
	LED_Display(LED_BOOT_RUN, LED_LIGHT);
	
	if(InitNandFlash())
	{
		FLUT_Configure(&skipBlockNf);
		
		memset(&BinItem, 0x0, sizeof(BinItem));
		
		BinItem.fileID = FLUT_ITEM_ID_ASYSTEM_FPGA;
		BinItem.bufferSize = NandCommon_MAXPAGEDATASIZE * NandCommon_MAXNUMPAGESPERBLOCK;
		BinItem.copyBuffer = (unsigned char *)AT91C_DDR2+MAX_CODE_SIZE;
		
		OS_ENTER_CRITICAL();
		error = FLUT_StartReadFile(&BinItem);
		OS_EXIT_CRITICAL();
		
		if(error != EC_FLUT_NO_ERROR)
		{
			TRACE_ERROR("StartReadFile failure: 0x%x \n\r", error);
			return FALSE;
		}
		
		do{
			OS_ENTER_CRITICAL();
			error = FLUT_ReadNextBuffer(&BinItem);
			OS_EXIT_CRITICAL();
			if(error == EC_FLUT_READ_NOT_COMPLETED || error == EC_FLUT_READ_COMPLETED)
			{
				checksum += CalcChksum(BinItem.copyBuffer, BinItem.readWrittenSize);
				memcpy((unsigned char*)AT91C_DDR2+MAX_CODE_SIZE+BinItem.bufferSize+copycount, BinItem.copyBuffer, BinItem.readWrittenSize);
				copycount += BinItem.readWrittenSize;
			}
			else
			{
				TRACE_ERROR("FLUT_ReadNextBuffer failure: 0x%x \n\r", error);
				TRACE_ERROR("coreBinItem.currentFilePosition : 0x%x \n\r",BinItem.currentFilePosition);
				TRACE_ERROR("coreBinItem.currentOffset : 0x%x \n\r",BinItem.currentOffset);
				return FALSE;
			}
		}while(error != EC_FLUT_READ_COMPLETED);
	}
	
	if(checksum != BinItem.writeFileOrCacheFile.Checksum)
		return FALSE;
	
	DeSecurity((unsigned char*)AT91C_DDR2+MAX_CODE_SIZE+BinItem.bufferSize, 
			   (unsigned char*)AT91C_DDR2+MAX_CODE_SIZE+BinItem.bufferSize, copycount);
	
	LED_Display(LED_BOOT_RUN, LED_DARK);
	
	*pFileLen = copycount;
	return TRUE;
}



